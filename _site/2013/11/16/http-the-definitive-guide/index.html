<!DOCTYPE HTML>
<html lang="en-US">
<head>
  <meta charset="UTF-8">
  <title>HTTP权威指南</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="generator" content="Jekyll v2.0.3">
  <link rel="alternate" type="application/rss+xml" title="Jekyll • Simple, blog-aware, static sites - Feed" href="/feed.xml">
  <link rel="alternate" type="application/atom+xml" title="Recent commits to Jekyll’s master branch" href="https://github.com/tuliang/commits/master.atom">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic,900">
  <link rel="stylesheet" href="/css/screen.css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <!--[if lt IE 9]>
  <script src="/js/html5shiv.min.js"></script>
  <script src="/js/respond.min.js"></script>
  <![endif]-->
</head>


<body class="wrap">
  <header>
  <nav class="mobile-nav show-on-mobiles">
    <ul>
  <li class="">
    <a href="/">Home</a>
  </li>
  <li class="">
    <a href="/about/">About</a>
  </li>
  <li>
    <a href="/feed.xml">via RSS</a>
  </li>
  <li>
    <a href="https://github.com/tuliang"><span class="hide-on-mobiles">View on </span>GitHub</a>
  </li>
</ul>

  </nav>
  <div class="grid">
    <nav class="main-nav unit two-thirds hide-on-mobiles">
      <ul>
  <li class="">
    <a href="/">Home</a>
  </li>
  <li class="">
    <a href="/about/">About</a>
  </li>
  <li>
    <a href="/feed.xml">via RSS</a>
  </li>
  <li>
    <a href="https://github.com/tuliang"><span class="hide-on-mobiles">View on </span>GitHub</a>
  </li>
</ul>

    </nav>
  </div>
</header>


    <section class="docs">
    <div class="grid">

      <div class="docs-nav-mobile unit whole show-on-mobiles">
  <select onchange="if (this.value) window.location.href=this.value">
    <option value="">Navigate the docs…</option>
    
  </select>
</div>


      <div class="unit four-fifths">
        <article>
          <h1>HTTP权威指南</h1>
          <p><img class="cover" src="/images/2013/10/9787115281487.jpg" /></p>

<p>原作名：HTTP: The Definitive Guide</p>

<p>ISBN：9787115281487</p>

<p>作者：David Gourley / Brian Totty </p>

<p>译者：陈涓 / 赵振平   </p>

<p>出版社：人民邮电出版社</p>

<p>出版时间：2012-9</p>

<p>评价：☆☆☆☆</p>

<p>本书大而全，HTTP协议十年来改动不大，大部分知识没有过时。对于某些方面的深入研究，作者在更多信息和注解中有介绍相关的<a href="http://book.douban.com/doulist/3157398/">参考书</a>。</p>

<p>第一部分 HTTP: Web的基础。讲述的是非常基础的东西，是每个做Web都应该了解的，现在看来几乎没有过时的部分。</p>

<p>第二部分 HTTP结构。内容深入了一些，更偏向后台和性能，同时也讲述了一章的Web机器人，而HTTP-NG现在应该没人再提这个了。</p>

<p>第三部分 识别、认证和安全。几乎将Web上安全方式都讲解了一遍，为了说明HTTPS还讲了一些数字加密技术的入门知识。</p>

<p>第四部分 实体、编码和国际化。比较详细的说明了编码方面的东西，如果不涉及这方面开发，可以跳过或者简单的扫一遍。</p>

<p>第五部分 内容发布与分发。虚拟主机、CDN这些部分可以看看（第18章），后面三章大部分过时了，基本没必要去看。</p>

<p>第六部分 附录。这些资料在做相关开发工作时有用，可以考虑把它们打印出来随时查阅。</p>

<p>总体推荐看第一、第二部分，其他部分选择性的观看。</p>

<p>Agent代理是代表用户发起HTTP请求的客户端程序。比如：Web浏览器以及搜索引擎的Web机器人(Web robots)。</p>

<p>URI是一个通用的概念，由两个主要的子集URL和URN构成，URL是通过描述资源的位置来标识资源的，而URN则是通过名字来识别资源的，与它们当前所处位置无关。</p>

<p>状态码：</p>

<ul>
<li><p>100~199 信息提示</p></li>
<li><p>200~299 成功</p></li>
<li><p>300~399 重定向</p></li>
<li><p>400~499 客户端错误</p></li>
<li><p>500~599 服务器错误</p></li>
</ul>

<p>最常见的TCP相关时延：</p>

<ul>
<li><p>TCP连接建立握手</p></li>
<li><p>TCP 慢启动拥塞控制</p></li>
<li><p>数据聚集的Nagle算法</p></li>
<li><p>用于捎带确认的TCP延迟确认算法</p></li>
<li><p>TIME_WAIT时延和端口耗尽</p></li>
</ul>

<p>MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。RFC 793中规定MSL为2分钟（这是一个历史原因，在很早之前路由器速度很慢），实际应用中有些操作系统会将其设置为一个较小的值。</p>

<p>2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</p>

<p>客户端每次连接到服务器上去时，都会获得一个新的源端口，以实现连接的唯一性。但由于可用源端口的数量有限（60000个），而且在2MSL秒（120秒）内连接是无法重用的，连接率就被限制在了60000/120=500次/秒。</p>

<p>有1个包含3个图片的页面。浏览器需要发起4个HTTP事务来显示此页面：1个用于HTML页面，3个用于图片。如果每个事务都需要一条新的连接，那么连接时延和慢启动时延就会叠加起来。</p>

<p>有几种方法可以提高HTTP的连接性能：  </p>

<ul>
<li><p>并行连接 - 通过多条TCP连接发起并发的HTTP请求。</p></li>
<li><p>持久连接 - 重用TCP连接，以消除连接及关闭时延。</p></li>
<li><p>管道化连接 - 通过共享的TCP连接发起并发的HTTP请求。</p></li>
<li><p>复用的连接 - 交替传送请求和响应报文（实验阶段）</p></li>
</ul>

<p>浏览器使用了并行连接，它们会将并行连接的总数限制为一个较小的值（通常是4个）。这是因为打开大量连接会消耗很多内存资源，从而引发客户端或是服务器的性能问题。</p>

<p>使用缓存有下列优点：</p>

<ul>
<li><p>减少了冗余的数据传输，节省了你的网络费用。</p></li>
<li><p>缓解了网络瓶颈的问题。不需要更多的带宽就能够更快地加载页面。</p></li>
<li><p>降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。</p></li>
<li><p>降低了距离时延，因为从较远的地方加载页面会更慢一些。</p></li>
</ul>

<p>摘要是“对信息主体的浓缩”。摘要是一种单向函数，主要用于将无限的输入值转换为有限的浓缩输出值。常见的摘要函数MD5，会将任意长度的字节序列转换为一个128位的摘要。安全散列算法（Secure Hash Algorithm, SHA）是另一种常见的摘要函数。</p>

        </article>
      </div>

      <div class="unit one-fifth hide-on-mobiles">
  <aside>
    
  </aside>
</div>


      <div class="clear"></div>

    </div>
  </section>


  <footer>
  <div class="grid">
    <div class="unit two-thirds align-right center-on-mobiles">
      <p>Published with <a href="http://pages.github.com">
        <img src="/img/footer-logo.svg" height="30" alt="GitHub Pages">
        </a>
      </p>
    </div>
  </div>
</footer>

  <script>
  var anchorForId = function (id) {
    var anchor = document.createElement("a");
    anchor.className = "header-link";
    anchor.href      = "#" + id;
    anchor.innerHTML = "<i class=\"fa fa-link\"></i>";
    return anchor;
  };

  var linkifyAnchors = function (level, containingElement) {
    var headers = containingElement.getElementsByTagName("h" + level);
    for (var h = 0; h < headers.length; h++) {
      var header = headers[h];

      if (typeof header.id !== "undefined" && header.id !== "") {
        header.appendChild(anchorForId(header.id));
      }
    }
  };

  document.onreadystatechange = function () {
    if (this.readyState === "complete") {
      var contentBlock = document.getElementsByClassName("docs")[0] || document.getElementsByClassName("news")[0];
      if (!contentBlock) {
        return;
      }
      for (var level = 1; level <= 6; level++) {
        linkifyAnchors(level, contentBlock);
      }
    }
  };
</script>

  




</body>
</html>
